(function(){"use strict";let s,a=0,f=!1,y=!1,d=[],h=!1,W=null,g=[];async function b(e){if(console.log("[Worker] Initializing with WASM URL:",e),!e)throw new Error("WASM URL not provided");const r=await import(e);console.log("[Worker] Module factory loaded.");const n={print:t=>console.log("[WASM Print]",t),printErr:t=>console.error("[WASM Error]",t),locateFile:t=>(console.log("[Worker] Locating file:",t),e.replace("lux.js",t))};try{s=await r.default(n),console.log("[Worker] Module instance created.")}catch(t){throw console.error("[Worker] Failed to initialize module:",t),new Error(`Module initialization failed: ${t.message}`)}const l=Object.keys(s).filter(t=>typeof s[t]=="function");console.log("[Worker] Module exports:",l);const c=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(t=>!(s&&typeof s[t]=="function"));if(c.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${c.join(", ")}]`),new Error(`Module recording functions missing: ${c.join(", ")}`)}function w(){if(s&&typeof s.get_recording_error=="function")try{const e=s.get_recording_error();return console.log("[Worker] C++ Error Details:",e),e||"No specific error available"}catch(e){return console.error("[Worker Helper] Failed to get C++ error:",e),"Failed to get C++ error: "+(e.message||e)}return"Module or get_recording_error not available"}function E(e,r,n=null){const l={context:e,cppError:r,jsError:n?n.message||n.toString():null,timestamp:new Date().toISOString(),recordingState:f,frameCount:a,queueSize:d.length};console.error("[Worker] Detailed Error Report:",l);const o=`${e}: C++[${r}]${n?` JS[${l.jsError}]`:""}`;return self.postMessage({type:"error",error:o,details:l}),o}async function _(){if(!(h||d.length===0)){h=!0;try{for(;d.length>0&&f;){const e=d.shift(),r=performance.now();try{const n=s.worker_add_frame(e.imageData,e.width,e.height),o=performance.now()-r;if(g.push(o),g.length>30&&(g=g.slice(-30)),n){if(a++,a%15===0){const c=g.reduce((m,i)=>m+i,0)/g.length,t=(performance.now()-W)/1e3,p=a/t;self.postMessage({type:"recordingProgress",frameCount:a,metrics:{avgProcessingTime:c,totalDuration:t,actualFps:p,queueSize:d.length}})}}else console.error(`[Worker] Failed to add frame ${a+1}`)}catch(n){console.error(`[Worker] Error processing frame ${a+1}:`,n)}}}finally{h=!1}}}self.onmessage=async e=>{const r=e.data;console.log("[Worker] Received message:",r.type);try{switch(r.type){case"init":if(y){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await b(r.wasmUrl),y=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(!y)throw new Error("Worker not initialized");f&&(console.log("[Worker] Already recording, stopping first"),await M()),console.log("[Worker] Starting recording with options:",r.options),f=!0,a=0,W=performance.now(),g=[];const n=s.get_buf_width(),l=s.get_buf_height();await s.start_recording(r.options.width,r.options.height,r.options.fps,r.options.bitrate,r.options.codec,r.options.format,r.options.preset)?self.postMessage({type:"recordingStarted",success:!0}):(f=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start recording"}));break;case"addFrame":if(!s||!s.worker_add_frame||!f){console.warn("[Worker] Ignoring frame - not ready or not recording");return}if(!r.imageData||!r.width||!r.height){console.error("[Worker] Invalid frame data");return}const c=r.width*r.height*4;if(r.imageData.length!==c){console.error("[Worker] Image data length mismatch:",{received:r.imageData.length,expected:c});return}if(h)d.push({imageData:r.imageData,width:r.width,height:r.height}),d.length>10&&(d.shift(),console.warn("[Worker] Dropped frame to maintain 30fps performance"));else{const i=performance.now();try{const u=s.worker_add_frame(r.imageData,r.width,r.height),v=performance.now()-i;g.push(v),g.length>30&&(g=g.slice(-30)),u?a++:console.error("[Worker] Failed to add frame immediately")}catch(u){console.error("[Worker] Error adding frame immediately:",u)}}_();break;case"stopRecording":if(!f){console.log("[Worker] Not recording");return}const p=(performance.now()-W)/1e3;console.log(`[Worker] Recording stopped after ${p.toFixed(2)}s with ${a} frames`),console.log(`[Worker] Average FPS: ${(a/p).toFixed(2)}`),f=!1,d.length>0&&await _();const m=await M();self.postMessage({...m,metrics:{totalDuration:p,totalFrames:a,averageFps:a/p}});break;case"getState":if(!s){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const i=typeof s.get_recording_state=="function"?s.get_recording_state():"unknown",u=typeof s.get_recorded_frame_count=="function"?s.get_recorded_frame_count():0,S=typeof s.is_recording=="function"?s.is_recording():!1;self.postMessage({type:"recorderState",state:i,frameCount:u,queueSize:0,isCppRecording:S,isWorkerRecording:f})}catch(i){console.error("[Worker] Exception during getState:",i),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",r.type)}}catch(n){console.error("[Worker] Error:",n),self.postMessage({type:"error",error:n.message})}};async function M(){try{console.log("[Worker] Stopping recording and finalizing..."),f=!1,d.length>0&&(console.log(`[Worker] Processing ${d.length} remaining frames before stopping`),await _());const e=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),r=/iPhone|iPad|iPod/i.test(navigator.userAgent||"");e&&(console.log(`[Worker] Mobile device detected: ${r?"iOS":"Android"}`),await new Promise(o=>setTimeout(o,100)));let n=!1,l=null;try{n=s.stop_recording()}catch(o){if(l=o,console.error("[Worker] Exception calling stop_recording:",o),e)console.log("[Worker] Mobile: Attempting to recover partial data after stop failure"),n=!1;else throw o}if(n||e&&!n){console.log(`[Worker] Recording ${n?"stopped successfully":"stopped with warnings (mobile)"}, getting data`);let o=null,c=null;try{o=s.get_recording_data()}catch(t){if(c=t,console.error("[Worker] Exception getting recording data:",t),e)console.log("[Worker] Mobile: Data retrieval failed, this is expected on some devices");else throw t}if(o&&o.length>0){console.log(`[Worker] Got ${o.length} bytes of video data`);const t=Array.from(o.slice(0,16)).map(k=>k.toString(16).padStart(2,"0")).join(" ");console.log("[Worker] First 16 bytes:",t);const p=e?100:1e3;if(o.length<p){const k=`Video data too small for ${e?"mobile":"desktop"}: ${o.length} bytes (min: ${p})`;if(e)console.warn("[Worker] "+k+" - attempting download anyway");else throw new Error(k)}const m=new ArrayBuffer(o.length),i=new Uint8Array(m);i.set(o);const u=s.get_recorded_frame_count()||0;console.log(`[Worker] Final frame count: ${u}`),i[4]===102&&i[5]===116&&i[6]===121&&i[7]===112||i[0]===0&&i[1]===0&&i[2]===0&&i[8]===102||(console.error("[Worker] Invalid MP4 header. Expected ftyp box"),console.error("[Worker] Got:",t),e?console.log("[Worker] Mobile: Invalid MP4 header detected, but continuing download..."):console.warn("[Worker] Desktop: Invalid MP4 header, but continuing anyway")),self.postMessage({type:"recordingStopped",success:!0,videoData:i,frameCount:u,mimeType:'video/mp4; codecs="avc1.42E01E"',duration:u/30,platform:e?r?"iOS":"Android":"Desktop",warnings:n?[]:["Stop recording had warnings but data recovered"],formatNote:"MP4 format - plays natively on all devices"},[m])}else{console.error("[Worker] No video data returned");const t={platform:e?r?"iOS":"Android":"Desktop",stopSuccess:n,stopError:l?l.message:null,dataError:c?c.message:null,frameCount:a||0,arrayLength:o?o.length:0,cppError:w()};console.error("[Worker] Error details:",t),self.postMessage({type:"recordingStopped",success:!1,error:`No video data available (${t.platform})`,details:t})}}else{const o=w();console.error("[Worker] stop_recording failed:",o);const c={platform:e?r?"iOS":"Android":"Desktop",cppError:o,stopError:l?l.message:null,frameCount:a||0,userAgent:navigator.userAgent||"unknown"},t=E("Stop Recording Failed",o);self.postMessage({type:"recordingStopped",success:!1,error:t,details:c})}}catch(e){console.error("[Worker] Exception during stopRecording:",e);const r=w(),n=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),l=/iPhone|iPad|iPod/i.test(navigator.userAgent||""),o={platform:n?l?"iOS":"Android":"Desktop",exception:e.message||e.toString(),cppError:r,stack:e.stack||"No stack trace",frameCount:a||0};console.error("[Worker] Exception details:",o);const c=E("Stop Recording Exception",r,e);self.postMessage({type:"recordingStopped",success:!1,error:c,details:o})}}self.addEventListener("error",e=>{if(console.error("[Worker Global Error]:",e.message,e.filename,e.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+e.message})}catch(r){console.error("[Worker Global Error] Could not send error message",r)}}),self.addEventListener("unhandledrejection",e=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",e.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(e.reason.message||e.reason.toString())})}catch(r){console.error("[Worker Global Error] Could not send rejection message",r)}}),console.log("[Worker] Video encoding worker initialized")})();
