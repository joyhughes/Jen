(function(){"use strict";let t,c=0,g=!1,y=!1,i=[],m=!1;const S=30;let w=null,R=null,p=[];const e=(n,r=null)=>{const a=`[${new Date().toISOString().slice(11,23)}] [Worker] ${n}`;console.log(a,r||"")};async function M(n){if(e("Initializing with WASM URL:",n),!n)throw new Error("WASM URL not provided");try{e("Attempting to import module factory...");const s=await import(n);e("Module factory loaded successfully");const u={print:l=>e("[WASM Print]",l),printErr:l=>e("[WASM Error]",l),locateFile:l=>(e("Locating file:",l),n.replace("lux.js",l)),importMemory:!0};e("Creating module instance with config..."),t=await s.default(u),e("Module instance created successfully")}catch(s){throw e("CRITICAL ERROR - Failed to initialize module:",s.message),e("Error stack:",s.stack),new Error(`Module initialization failed: ${s.message}`)}const r=Object.keys(t).filter(s=>typeof t[s]=="function");e("Module exports count:",r.length),e("First 10 exports:",r.slice(0,10));const a=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(s=>!(t&&typeof t[s]=="function"));if(a.length===0)e("✓ All critical recording functions verified");else throw e(`ERROR - Missing required recording functions: [${a.join(", ")}]`),new Error(`Module recording functions missing: ${a.join(", ")}`)}function W(){if(t&&typeof t.get_recording_error=="function")try{return t.get_recording_error()}catch(n){return console.error("[Worker Helper] Failed to get C++ error:",n),"Failed to get C++ error: "+(n.message||n)}return"Module or get_recording_error not available"}async function k(){if(console.log("[Worker] === PROCESS FRAME QUEUE START ==="),console.log("[Worker] isProcessingFrames:",m),console.log("[Worker] frameQueue.length:",i.length),console.log("[Worker] recordingInProgress:",g),m||i.length===0){console.log("[Worker] Skipping frame processing - already processing or empty queue");return}m=!0;const n=5;console.log("[Worker] Starting frame processing with batch size:",n);try{for(;i.length>0;){const r=i.splice(0,n);console.log("[Worker] Processing batch of",r.length,"frames. Remaining in queue:",i.length);for(const o of r){const a=performance.now();try{if(console.log(`[Worker] === PROCESSING FRAME ${c+1} ===`),console.log(`[Worker] Frame dimensions: ${o.width}x${o.height}`),console.log("[Worker] Frame imageData type:",o.imageData.constructor.name),console.log("[Worker] Frame imageData length:",o.imageData.length),console.log("[Worker] Expected length:",o.width*o.height*4),console.log(`[Worker] Queue remaining: ${i.length}, recording: ${g}`),!t||typeof t.worker_add_frame!="function"){console.error("[Worker] CppModule or worker_add_frame not available"),console.error("[Worker] - CppModule:",!!t),console.error("[Worker] - worker_add_frame type:",typeof(t&&t.worker_add_frame));continue}if(!o.imageData||!o.width||!o.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!o.imageData,width:o.width,height:o.height});continue}console.log("[Worker] Calling CppModule.worker_add_frame...");const s=t.worker_add_frame(o.imageData,o.width,o.height);console.log("[Worker] worker_add_frame returned:",s);const l=performance.now()-a;if(p.push(l),s){if(c++,console.log(`[Worker] ✓ Frame ${c} added successfully in ${l.toFixed(2)}ms`),c%10===0){const f=p.reduce((_,F)=>_+F,0)/p.length,h=(performance.now()-w)/1e3,C=c/h;console.log(`[Worker] Performance metrics:
                                Frame #${c}
                                Queue size: ${i.length}
                                Avg processing time: ${f.toFixed(2)}ms
                                Total duration: ${h.toFixed(2)}s
                                Actual FPS: ${C.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:c,metrics:{avgProcessingTime:f,totalDuration:h,actualFps:C,queueSize:i.length}}),p=[]}}else{if(console.error(`[Worker] ✗ Failed to add frame ${c+1} - C++ function returned false`),typeof t.get_recording_error=="function"){const f=t.get_recording_error();console.error(`[Worker] C++ error: ${f}`)}if(typeof t.get_recording_state=="function"){const f=t.get_recording_state();console.error(`[Worker] Recording state: ${f}`)}if(typeof t.is_recording=="function"){const f=t.is_recording();console.error(`[Worker] C++ is_recording: ${f}`)}}}catch(s){console.error(`[Worker] ✗ Exception adding frame ${c+1}:`,s),console.error("[Worker] Frame data:",{hasImageData:!!o.imageData,imageDataLength:o.imageData?o.imageData.length:0,width:o.width,height:o.height,expectedLength:o.width*o.height*4})}}await new Promise(o=>setTimeout(o,0))}}finally{m=!1,console.log("[Worker] === PROCESS FRAME QUEUE END ==="),console.log("[Worker] Final queue size:",i.length),console.log("[Worker] Total frames processed:",c)}}self.onmessage=async n=>{const r=n.data;e("Received message:",r.type);try{switch(r.type){case"init":if(y){e("Already initialized");return}e("Initializing worker..."),await M(r.wasmUrl),y=!0,e("✓ Worker initialization complete"),self.postMessage({type:"initialized"});break;case"startRecording":if(e("=== START RECORDING REQUEST ==="),e("isInitialized:",y),e("recordingInProgress:",g),!y)throw e("ERROR: Worker not initialized"),new Error("Worker not initialized");g&&(e("Already recording, stopping first"),await E()),e("Resetting recording state for fresh start..."),c=0,i=[],m=!1,w=performance.now(),R=null,p=[],e("Recording state reset complete:",{frameCount:c,queueLength:i.length,isProcessingFrames:m}),e("Starting H.264/MP4 recording with options:",r.options),e("Original options dimensions:",r.options.width,"x",r.options.height),g=!0,e("Using adaptive canvas dimensions for recording...");let o=r.options.width,a=r.options.height;o%2!==0&&(o=o-1,e(`Adjusted width to even number: ${o}`)),a%2!==0&&(a=a-1,e(`Adjusted height to even number: ${a}`));const s=1920,u=16;if((o>s||a>s)&&e(`WARNING: Large dimensions (${o}x${a}) may cause issues on mobile devices`),o<u||a<u){e(`ERROR: Dimensions too small (${o}x${a}), minimum is ${u}x${u}`),g=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Dimensions too small for H.264 encoding"});return}e(`Final recording dimensions: ${o}x${a}`),e(`Original canvas dimensions: ${r.options.width}x${r.options.height}`);const l=t.get_buf_width(),f=t.get_buf_height();e(`Buffer dimensions (for reference): ${l}x${f}`),e("Calling C++ start_recording with CANVAS dimensions:"),e("- Width:",o),e("- Height:",a),e("- FPS:",r.options.fps),e("- Bitrate:",r.options.bitrate),e("- Codec:",r.options.codec),e("- Format:",r.options.format),e("- Preset:",r.options.preset);const h=await t.start_recording(o,a,r.options.fps,r.options.bitrate,r.options.codec,r.options.format,r.options.preset);if(e("start_recording returned:",h),h){if(e("✓ Recording started successfully"),typeof t.get_recording_state=="function"){const d=t.get_recording_state();e("C++ recording state after start:",d)}if(typeof t.is_recording=="function"){const d=t.is_recording();e("C++ is_recording after start:",d)}i.length>0&&(e(`Processing ${i.length} frames that were queued while waiting for backend`),k()),self.postMessage({type:"recordingStarted",success:!0})}else{if(e("✗ Failed to start H.264 recording"),typeof t.get_recording_error=="function"){const d=t.get_recording_error();e("C++ error:",d)}g=!1,i.length>0&&(e(`Clearing ${i.length} queued frames due to recording failure`),i=[]),self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start H.264 recording"})}break;case"addFrame":if(e("=== ADD FRAME REQUEST ==="),e("CppModule available:",!!t),e("worker_add_frame available:",!!(t&&t.worker_add_frame)),e("recordingInProgress:",g),!g){e("Rejecting frame - recording not in progress");return}if(!t||!t.worker_add_frame){e("Module not ready, queuing frame for when backend is ready"),e("- CppModule:",!!t),e("- worker_add_frame:",!!(t&&t.worker_add_frame)),r.imageData&&r.width&&r.height&&(i.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame queued while waiting for backend. Queue size:",i.length));return}if(e("Frame data validation:"),e("- hasImageData:",!!r.imageData),e("- width:",r.width),e("- height:",r.height),e("- imageData type:",r.imageData?r.imageData.constructor.name:"null"),e("- imageData length:",r.imageData?r.imageData.length:0),e("- expected length:",r.width*r.height*4),!r.imageData||!r.width||!r.height){e("Invalid frame data:",{hasImageData:!!r.imageData,width:r.width,height:r.height});return}if(typeof t.get_recording_state=="function"){const d=t.get_recording_state();e("Current C++ recording state:",d)}if(typeof t.is_recording=="function"){const d=t.is_recording();if(e("C++ is_recording:",d),!d){e("C++ not ready yet, queuing frame"),i.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame queued waiting for C++ ready. Queue size:",i.length);return}}e("Adding frame to queue. Current queue size:",i.length),i.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame added to queue. New queue size:",i.length),i.length>=S&&(e("Queue size reached MAX_QUEUE_SIZE, processing frames"),k());break;case"stopRecording":if(!g){e("Not recording");return}const _=(performance.now()-w)/1e3;e(`Recording stopped after ${_.toFixed(2)}s with ${c} frames`),e(`Average FPS: ${(c/_).toFixed(2)}`),g=!1,r.flushQueue?(e(`Flushing ${i.length} remaining frames from queue (will not be processed)`),i=[],e("Frame queue flushed - starting clean for next recording")):i.length>0&&(e(`Processing ${i.length} remaining frames before stopping`),await k());const F=await E();self.postMessage({...F,metrics:{totalDuration:_,totalFrames:c,averageFps:c/_}});break;case"getState":if(!t){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const d=typeof t.get_recording_state=="function"?t.get_recording_state():"unknown",D=typeof t.get_recorded_frame_count=="function"?t.get_recorded_frame_count():0,$=typeof t.is_recording=="function"?t.is_recording():!1;self.postMessage({type:"recorderState",state:d,frameCount:D,queueSize:0,isCppRecording:$,isWorkerRecording:g})}catch(d){e("Exception during getState:",d.message),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:e("Unknown message type:",r.type)}}catch(o){e("CRITICAL ERROR in message handler:",o.message),e("Error stack:",o.stack),self.postMessage({type:"error",error:o.message})}};async function E(){try{if(e("Stopping recording and finalizing..."),g=!1,m=!1,i.length>0&&(e(`Processing ${i.length} remaining frames before stopping`),await k()),t.stop_recording()){e("Recording stopped successfully, getting data");const r=t.get_recording_data();if(r&&r.length>0){e(`Got ${r.length} bytes of video data`);const o=Array.from(r.slice(0,16)).map(f=>f.toString(16).padStart(2,"0")).join(" ");if(e("First 16 bytes:",o),r.length<1e3)throw new Error("Video data too small, likely corrupted");const a=new ArrayBuffer(r.length),s=new Uint8Array(a);s.set(r);const u=t.get_recorded_frame_count()||0;e(`Final frame count: ${u}`),s[4]===102&&s[5]===116&&s[6]===121&&s[7]===112||(e("Warning: MP4 header not detected. Expected ftyp box (66 74 79 70)"),e("Got:",o)),e("Cleaning up state for next recording..."),i=[],m=!1,c=0,w=null,R=null,p=[],e("State cleanup complete:",{frameQueue:i.length,isProcessingFrames:m,frameCount:c}),self.postMessage({type:"recordingStopped",success:!0,videoData:s,frameCount:u,mimeType:'video/mp4; codecs="avc1.42E01E"',duration:u/30},[a])}else e("No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const r=W();e("stop_recording failed:",r),self.postMessage({type:"recordingStopped",success:!1,error:`Stop recording failed: ${r}`})}}catch(n){e("Exception during stopRecording:",n),self.postMessage({type:"recordingStopped",success:!1,error:"Exception: "+(n.message||n.toString())})}finally{e("Final cleanup - ensuring clean state..."),g=!1,m=!1,i=[],c=0,w=null,R=null,p=[],e("Final cleanup complete - ready for next recording")}}self.addEventListener("error",n=>{if(e("CRITICAL ERROR in global error handler:",n.message,n.filename,n.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+n.message})}catch{e("CRITICAL ERROR: Could not send error message")}}),self.addEventListener("unhandledrejection",n=>{if(e("CRITICAL ERROR in global error handler:",n.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(n.reason.message||n.reason.toString())})}catch{e("CRITICAL ERROR: Could not send rejection message")}}),e("H.264/MP4 video encoding worker initialized")})();
